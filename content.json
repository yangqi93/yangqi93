{"meta":{"title":"Nutshell's blog","subtitle":"What we think, we become.","description":null,"author":"yangqi","url":"https://nutshell.com"},"pages":[{"title":"关于","date":"2018-05-10T01:44:14.000Z","updated":"2018-09-05T06:28:42.230Z","comments":true,"path":"about/index.html","permalink":"https://nutshell.com/about/index.html","excerpt":"","text":"嗨，我是杨淇!93年中二青年. 目前以编程为生，喜欢晒太阳和睡觉 联系我e-mailnutshell.qi@gmail.com"},{"title":"categories","date":"2018-05-10T03:33:58.000Z","updated":"2018-05-10T12:52:51.182Z","comments":true,"path":"categories/index.html","permalink":"https://nutshell.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-10T03:33:25.000Z","updated":"2018-05-10T12:52:51.186Z","comments":true,"path":"tags/index.html","permalink":"https://nutshell.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mysql 备份脚本","slug":"Mysql备份脚本","date":"2018-09-26T09:37:43.000Z","updated":"2018-09-27T02:05:35.803Z","comments":true,"path":"2018/09/26/Mysql备份脚本/","link":"","permalink":"https://nutshell.com/2018/09/26/Mysql备份脚本/","excerpt":"定时备份数据库，删除过期备份","text":"定时备份数据库，删除过期备份 基础脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env bash#备份目录backupDir=/home/yangqi/backup#日志文件log=$&#123;backupDir&#125;/log.txt######### Mysql Config ##############host=\"127.0.0.1\"user=\"root\"pswd=\"123\"databases=(article)######################################今天的日期及当前时间（小时）now=`date +%Y%m%d%H`hour=`date +%H`#3天前的日期timeThreeDayAgo=`date +%Y%m%d%H --date='-3 day'`timeTowDayAgo=`date +%Y%m%d%H --date='-2 day'`timeOneDayAgo=`date +%Y%m%d%H --date='-1 day'`#开始备份if [ ! -d \"$backupDir\" ]; then mkdir \"$backupDir\"fifor database in $&#123;databases[@]&#125;do echo \"开始备份$&#123;database&#125; `date +%Y%m%d-%H%M%S`\" &gt;&gt; $log mysqldump --default-character-set=utf8mb4 --set-gtid-purged=OFF -h$&#123;host&#125; -u$&#123;user&#125; -p$&#123;pswd&#125; $&#123;database&#125;| gzip &gt; $&#123;backupDir&#125;/$&#123;database&#125;-$&#123;now&#125;.sql.gz echo \"成功备份$&#123;database&#125; 到$&#123;backupDir&#125;\" &gt;&gt; $log#删除指定的备份 if [ ! -f \"$&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeTenDayAgo&#125;.sql.gz\" ]; then echo \"3天前备份不存在，无需删除\" &gt;&gt; $log else rm -f $&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeTenDayAgo&#125;.sql.gz echo \"删除3天前备份 $&#123;database&#125;-$&#123;timeTenDayAgo&#125;.sql.gz\" &gt;&gt; $log fi #两天前删除00/12点备份 #一天前删除00/06/12/18点备份 need1=(00 12 17) if [[ $&#123;need1[@]&#125; =~ $&#123;hour&#125; ]]; then if [ -f \"$&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeTwoDayAgo&#125;.sql.gz\" ]; then rm -f $&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeTwoDayAgo&#125;.sql.gz echo \"删除2天前备份 $&#123;database&#125;-$&#123;timeTwoDayAgo&#125;.sql.gz\" &gt;&gt; $log fi if [ -f \"$&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeOneDayAgo&#125;.sql.gz\" ]; then rm -f $&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeOneDayAgo&#125;.sql.gz echo \"删除1天前备份 $&#123;database&#125;-$&#123;timeOneDayAgo&#125;.sql.gz\" &gt;&gt; $log fi fi need2=(06 18) if [[ $&#123;need2[@]&#125; =~ $&#123;hour&#125; ]]; then if [ -f \"$&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeTwoDayAgo&#125;.sql.gz\" ]; then rm -f $&#123;backupDir&#125;/$&#123;database&#125;-$&#123;timeTwoDayAgo&#125;.sql.gz echo \"删除2天前备份 $&#123;database&#125;-$&#123;timeTwoDayAgo&#125;.sql.gz\" &gt;&gt; $log fi fi doneecho -e \"执行结束\\n\\n\" &gt;&gt; $log 也许你需要区分系统12345678910#系统 os_name [Linux / Darwin(Mac OS)]os_name=`uname -s`#今天的日期 Ymdtoday=`date +%Y%m%d`#10天前的日期 根据系统区别获取if [ \"$os_name\" == \"Linux\" ]; then timeTenDayAgo=`date +%Y%m%d --date='-10 day'`elif [ \"$os_name\" == \"Darwin\" ]; then timeTenDayAgo=`date -v -10d +%Y%m%d`fi","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://nutshell.com/categories/环境配置/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://nutshell.com/tags/Mysql/"}]},{"title":"Nginx gzip 配置和性能测试","slug":"Nginx-gzip-配置和性能测试","date":"2018-09-25T06:37:43.000Z","updated":"2018-09-27T02:11:21.441Z","comments":true,"path":"2018/09/25/Nginx-gzip-配置和性能测试/","link":"","permalink":"https://nutshell.com/2018/09/25/Nginx-gzip-配置和性能测试/","excerpt":"网站加载的速度取决于浏览器必须下载的所有文件的大小。减少要传输的文件的大小可以使网站不仅加载更快，而且对于那些宽带是按量计费的人来说也更友好。 gzip是一种流行的数据压缩程序。您可以使用gzip压缩Nginx实时文件。这些文件在检索时由支持它的浏览器解压缩，好处是web服务器和浏览器之间传输的数据量更小，速度更快。 gzip不一定适用于所有文件的压缩。例如，文本文件压缩得非常好，通常会缩小两倍以上。另一方面，诸如JPEG或PNG文件之类的图像已经按其性质进行压缩，使用gzip压缩很难有好的压缩效果或者甚至没有效果。压缩文件会占用服务器资源，因此最好只压缩那些压缩效果好的文件。","text":"网站加载的速度取决于浏览器必须下载的所有文件的大小。减少要传输的文件的大小可以使网站不仅加载更快，而且对于那些宽带是按量计费的人来说也更友好。 gzip是一种流行的数据压缩程序。您可以使用gzip压缩Nginx实时文件。这些文件在检索时由支持它的浏览器解压缩，好处是web服务器和浏览器之间传输的数据量更小，速度更快。 gzip不一定适用于所有文件的压缩。例如，文本文件压缩得非常好，通常会缩小两倍以上。另一方面，诸如JPEG或PNG文件之类的图像已经按其性质进行压缩，使用gzip压缩很难有好的压缩效果或者甚至没有效果。压缩文件会占用服务器资源，因此最好只压缩那些压缩效果好的文件。 参考博文 作者：腾讯云加社区 链接：https://juejin.im/post/5b518d1a6fb9a04fe548e8fc 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 http://www.cnblogs.com/xzkzzz/p/9224358.html Nginx gzip参数详解及常见问题 配置12345gzip on;gzip_vary on;gzip_min_length 1k;gzip_comp_level 1;gzip_types text/plain application/json application/javascript application/x-javascript text/css application/xml text/javascript; gzip 开关 gzip_vary 和http头有关系，加个vary 头，给代理服务器用的，有的浏览器支持压缩，有的不支持，根据客户端的http 头来判断，是否需要压缩 gzip_min_length 需要压缩的文件最小值 gzip_comp_level 压缩级别 gzip_types 需要压缩的文件类型 性能比较 gzip_comp_level 取值对响应大小的影响设置gzip压缩级别，级别越低压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大，取值范围1-9 原文件大小 24.6kb该值为 1-9 的结果分别为 1 6.4kb 2 6.1kb 3 6.3kb 4 5.9kb 5 5.8kb 6 5.8kb 7 5.8kb 8 5.6kb 9 5.6kb 压缩级别6以后无明显提升 gzip 前后 cpu 消耗对比以无压缩及压缩级别1和5分别测试在5000个并发请求，500个并发用户环境下的cpu消耗| 90%请求响应时间 无压缩 压缩级别1 压缩级别5 文件大小 70.6kb 8.1kb 7.5kb cpu消耗 24% 25% 29% ab测试90%请求响应时间 17ms 12ms 15ms 由此可以看出：没有开启gzip时，cpu消耗最低，但文本无压缩，请求最慢；压缩级别为1时，文件大小明显变小，cpu消耗略有上升，请求时间明显减少;压缩级别为5时，文件大小较压缩级别1无明显变化，cpu消耗上升较快，请求时间也变长。 根据本次测试结果，最优配置应为开启gzip,并将压缩级别设置为1。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://nutshell.com/categories/环境配置/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://nutshell.com/tags/Nginx/"}]},{"title":"Yii2 数据库迁移","slug":"Yii2 数据库迁移","date":"2018-09-10T09:51:56.000Z","updated":"2018-09-27T01:58:48.604Z","comments":true,"path":"2018/09/10/Yii2 数据库迁移/","link":"","permalink":"https://nutshell.com/2018/09/10/Yii2 数据库迁移/","excerpt":"官方文档 db-migrations 本文基于版本 2.0.15, 主要是一些使用示例一个数据库迁移文件记录了数据库的变更，增加或删除表、字段、索引，又或者是初始数据的写入。要保持开发者或环境间数据库结构一致，主要通过创建迁移和提交迁移这两部完成。","text":"官方文档 db-migrations 本文基于版本 2.0.15, 主要是一些使用示例一个数据库迁移文件记录了数据库的变更，增加或删除表、字段、索引，又或者是初始数据的写入。要保持开发者或环境间数据库结构一致，主要通过创建迁移和提交迁移这两部完成。 [迁移文件之初识]创建迁移固定格式为 yii migrate/create &lt;name&gt; 生成迁移文件12345678910111213141516171819class m150811_220037_create_post extends Migration&#123; //150811_220037 是创建迁移的时间戳, create_post 则是创建迁移时的&lt;name&gt; //up()方法是执行迁移的内容，down()是回滚，对应的方法有safeUp()/safeDown(), 它们的区别是后者处于事务中 public function up() &#123; $this-&gt;createTable('post', [ 'id' =&gt; $this-&gt;primaryKey(), 'title' =&gt; $this-&gt;string(12)-&gt;notNull()-&gt;unique(), 'body' =&gt; $this-&gt;text() ]); &#125; public function down() &#123; $this-&gt;dropTable('post'); &#125;&#125; 提交迁移上一步创建迁移会生成相应的文件，执行命令 yii migrate 提交，会生成迁移记录到 migrate 表并执行数据库操作执行 yii migrate/down 可以回滚迁移 [表操作]以表名 post 为例 创建数据表yii migrate/create create_post 123456789101112131415161718class m180911_012729_create_post extends Migration&#123; const TABLE_NAME = 'post'; public function safeUp() &#123; $this-&gt;createTable(self::TABLE_NAME, [ 'id' =&gt; $this-&gt;primaryKey(), 'title' =&gt; $this-&gt;string(12)-&gt;notNull()-&gt;defaultValue(''), 'body' =&gt; $this-&gt;text() ]); &#125; public function safeDown() &#123; $this-&gt;dropTable(self::TABLE_NAME); &#125;&#125; 删除数据表yii migrate/create drop_table 123456789101112131415161718class m180911_013541_drop_post extends Migration&#123; const TABLE_NAME = 'post'; public function safeUp() &#123; $this-&gt;dropTable(self::TABLE_NAME); &#125; public function safeDown() &#123; $this-&gt;createTable(self::TABLE_NAME, [ 'id' =&gt; $this-&gt;primaryKey(), 'title' =&gt; $this-&gt;string(12)-&gt;notNull()-&gt;defaultValue(''), 'body' =&gt; $this-&gt;text() ]); &#125;&#125; 修改表结构yii migrate/create alter_post_add_coloumn_author 1234567891011121314class m180911_013858_alter_post_add_coloumn_author extends Migration&#123; const TABLE_NAME = 'post'; public function safeUp() &#123; $this-&gt;addColumn(self::TABLE_NAME, 'author', $this-&gt;tinyInteger(6)); &#125; public function safeDown() &#123; $this-&gt;dropColumn(self::TABLE_NAME, 'author'); &#125;&#125; [字段操作]常见字段类型 主键$this-&gt;primaryKey() 数值$this-&gt;tinyInteger()$this-&gt;integer()$this-&gt;bigInteger() 字符串$this-&gt;string() 文本$this-&gt;text() 其它可用方法1234notNull defaultValue unique comment [索引操作]添加索引$this-&gt;createIndex(&#39;author&#39;, self::TABLE_NAME, &#39;author&#39;); 删除索引$this-&gt;dropIndex(&#39;author&#39;, self::TABLE_NAME); [更快速方便的选择]你也可以先创建数据库结构，然后使用组件 jamband/yii2-schemadump 分析生成迁移代码，再复制到相应的up()/down()方法中jamband/yii2-schemadump","categories":[{"name":"Yii2","slug":"Yii2","permalink":"https://nutshell.com/categories/Yii2/"}],"tags":[{"name":"Yii2","slug":"Yii2","permalink":"https://nutshell.com/tags/Yii2/"},{"name":"数据库迁移","slug":"数据库迁移","permalink":"https://nutshell.com/tags/数据库迁移/"}]},{"title":"PHP环境配置与优化（Ubuntu16.04/PHP7)","slug":"PHP环境配置与优化（Ubuntu16-04-PHP7","date":"2018-07-02T08:51:56.000Z","updated":"2018-07-02T09:47:07.337Z","comments":true,"path":"2018/07/02/PHP环境配置与优化（Ubuntu16-04-PHP7/","link":"","permalink":"https://nutshell.com/2018/07/02/PHP环境配置与优化（Ubuntu16-04-PHP7/","excerpt":"参考：Modern PHP.Josh Lockhart.中国电力出版社.第7章.配置 [配置]PHP-FPM用于管理PHP进程池的软件，用于接收和处理来自Web服务器的请求。","text":"参考：Modern PHP.Josh Lockhart.中国电力出版社.第7章.配置 [配置]PHP-FPM用于管理PHP进程池的软件，用于接收和处理来自Web服务器的请求。全局配置(/etc/php/7.0/fpm/php-fpm.conf)//这两个配置是在指定时间内有指定个子进程失效，让PHP-FPM重启。12emergency_restart_threshold = 10emergency_restart_interval = 1m 配置进程池(/etc/php/7.0/fpm/pool.d/*.conf)PHP-FPM进程池中是一系列相关的PHP子进程。 123456789101112131415161718192021222324//拥有这个子进程的系统用户user = examplegroup = deploy//监听地址和端口号listen = 127.0.0.1:9000listen.allowed_slients = 127.0.0.1//进程池中最多能有多少个进程pm.max_children = 50//初始化准备进程数pm.start_servers = 3//空闲时最少进程数和最大进程数pm.min_spare_servers = 2pm.max_spare_servers = 4//最多能处理的进程数pm.max_requests = 1000//记录超过指定时间的请求，这个日志能看到超时前最后具体的调用方法，两个设置必须配合使用slowlog = /path/to/slowlog.logrequest_slowlog_timeout = 5s 虚拟主机1234567891011121314151617181920212223242526272829303132333435363738//简单列出平时调试的虚拟主机，仅供参考server &#123; listen 80 default_server; listen [::]:80 default_server;//主机名 server_name dev.company *.dev.company; set $sub 'dev'; if ($host ~ \"^(.*).dev.company\") &#123; set $sub $1; &#125; set $web '/web';//文档根目录 root /home/yangqi/www/$sub$web; sendfile off;//访问日志与错误日志，请确认路经是否存在 access_log /home/yangqi/www/logs/$sub.access.log; error_log /home/yangqi/www/logs/$sub.error.log;//默认寻找的文件 index index.php index.html index.htm adminer.php; try_files $uri $uri/ /index.php?$args;//告诉nginx如何处理匹配指定URL模式（try_files）的HTTP请求 location ~ \\.php$ &#123; fastcgi_split_path_info ^(.+\\.php)(/.+)$; # # NOTE: You should have \"cgi.fix_pathinfo = 0;\" in php.ini # fastcgi_pass 127.0.0.1:9000; fastcgi_pass unix:/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; [调优]所有调整都是在php.ini文件中进行（/etc/php/7.0/fpm/php.ini） 内存1234567//设置单个PHP进程可以使用的内存最大值memory_limit//考虑这个值应该思考几个问题一共能分配多少内存给PHP？单个PHP进程平均消耗多少内存？能负担得起多少个PHP-FPM进程？ Zend OpcachZend Opcach 用于缓存操作码（PHP读取脚本后编译得到） 123456789101112131415//为操作码缓存分配的内存量opcache.memory_consumption = 64//用来存储驻留字符串opcache.interned_strings_buffer = 16//最多可以缓存的PHP脚本数量（一定要比PHP应用的文件数量大）opcache.max_accelerated_files = 4000//是否检查PHP脚本的变化，频率由revalidate_freq决定opcache.validate_timestamps = 1 //生产环境应设为0opcache.revalidate_freq = 0//把对象析构和内存释放交给Zend Engine的内存管理器完成opcache.fast_shutdown = 1 文件上传123file_uploads = 1upload_max_filesize = 10Mmax_file_uploads = 3 最长执行时间1max_execution_time = 5 处理会话123//使用文件存储session会占用磁盘，而且不便于服务器扩展，使用Redis/Memcached统一更合适session.save_handler = 'memcached'session.save_part = '127.0.0.2:11211' 缓冲输出123//在较少的片段中把数据返回给请求者的浏览器，4096作为一个片段，可以减少一次发送的片段总数output_buffering = 4096lmplict_flush = false 真实路经缓存12//可以使用在脚本末尾使用realpath_cache_size()查看实际大小realpath_cache_size = 64k","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://nutshell.com/categories/环境配置/"}],"tags":[{"name":"PHP7","slug":"PHP7","permalink":"https://nutshell.com/tags/PHP7/"},{"name":"PHP配置优化","slug":"PHP配置优化","permalink":"https://nutshell.com/tags/PHP配置优化/"}]},{"title":"Laravel 使用 API Resources & Dingo & JWT 构建 api 踩过的坑","slug":"Laravel-使用-API-Resources-Dingo-JWT-构建-api-踩过的坑","date":"2018-05-25T02:19:54.000Z","updated":"2018-05-29T03:55:18.988Z","comments":true,"path":"2018/05/25/Laravel-使用-API-Resources-Dingo-JWT-构建-api-踩过的坑/","link":"","permalink":"https://nutshell.com/2018/05/25/Laravel-使用-API-Resources-Dingo-JWT-构建-api-踩过的坑/","excerpt":"记录开发 API 时遇到的常见错误和问题。","text":"记录开发 API 时遇到的常见错误和问题。 Route 相关路由隐式绑定不工作routes/api.php12345678910$api-&gt;get('users/&#123;user&#125;', ['as' =&gt; 'users.show', 'uses' =&gt; 'UserController@show']);``` UserController.php```phppublic function show(User $user)&#123; dd($user); return $this-&gt;response-&gt;item($user, new UserTransformer);&#125; 按照 Laravel 路由规则，请求地址为 api/users/1 时，该路由会自动找到 id 为1的用户，但是这里并没有生效。 在中间件加上 bindings 即可12$api-&gt;group(['middleware' =&gt; 'api.auth|bindings'], function ($api) &#123; &#125;); 参考：Route Model Binding not working correctly","categories":[{"name":"Laravel","slug":"laravel","permalink":"https://nutshell.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nutshell.com/tags/laravel/"},{"name":"api","slug":"api","permalink":"https://nutshell.com/tags/api/"},{"name":"dingo","slug":"dingo","permalink":"https://nutshell.com/tags/dingo/"},{"name":"resources","slug":"resources","permalink":"https://nutshell.com/tags/resources/"}]},{"title":"Yii2.0陪我走过的那些日子","slug":"Yii2-0陪我走过的那些日子","date":"2018-05-22T06:00:50.000Z","updated":"2018-09-27T01:19:31.725Z","comments":true,"path":"2018/05/22/Yii2-0陪我走过的那些日子/","link":"","permalink":"https://nutshell.com/2018/05/22/Yii2-0陪我走过的那些日子/","excerpt":"参考：深入理解Yii2.0 www.digpage.com Yii 使用经历和感想我在学习阶段使用过ThinkPHP, 自工作伊始就一直使用YII，大多数工作局限在MVC。相当多的代码是参考文档一点点凑起来的，只需要少量的代码就可以完成很多工作，甚至Yii还提供了代码生成工具Gii。对于这些代码知其用不知其所以然，反正觉得Yii真是方便。","text":"参考：深入理解Yii2.0 www.digpage.com Yii 使用经历和感想我在学习阶段使用过ThinkPHP, 自工作伊始就一直使用YII，大多数工作局限在MVC。相当多的代码是参考文档一点点凑起来的，只需要少量的代码就可以完成很多工作，甚至Yii还提供了代码生成工具Gii。对于这些代码知其用不知其所以然，反正觉得Yii真是方便。 这个框架对于生成基础的表单，数据展示也是一套一套的，但是想要进行修改时就比较头疼了，比如一个GridView, 当我想在某一列中加上一个class时就不知从何下手，并不知道他还有什么属性可以配置。在它有强大的类手册可以参考，这一点对我的开发帮助很大。 在上面这个场景中，我们可以先找到 yii\\grid\\GridView，发现它有一个$columns属性可以配置，继而找到这个属性的类yii\\grid\\DataColumn，通过$filterInputOptions属性便可以自定义这个列的class了。这只是冰山一角，坑是永远填不完的，比如model中的行为是如何自动完成created_at和update_at的写入的呢？又是如何完成验证的呢？这些问题一个接一个。 基于这些使用经验，隐约感觉到Yii的强大，就像是一辆汽车每一个零部件可追溯。源于同事的推荐，发现一个神奇的网站，www.digpage.com 看完它似醍醐灌顶，如此往复，任督二脉打通也指日可待。 基础指哪些以及它们之间的关联Yii 基础指属性（Property），事件(Event)，行为(Behavior)。 属性属性构成了一切对象的基础。在Yii中很常见的配置就是各种属性。 事件事件模型就是设计模式中的“观察者模式”：当对象的状态发生了变化，那么这个对象可以将该事件通知其它对象。为了使用事件模型，需要实现这三个步骤：1、定义事件；2、绑定事件句柄；3、触发事件。事件在Yii中无处不在，beforeSave(), afterSave(), beforeValidate(), afterValidate()… 一个请求周期中会触发n个事件，我们就可以利用这些事件搞事啦 行为行为可以将自己的属性和方法注入到要绑定的类中去，一个类还可以绑定多个行为，通过在行为中定义事件完成数据处理。 自动完成 created_at 和 update_at 就是使用了yii\\behaviors\\TimeStampBehavior, 这个行为继承自yii\\behaviors\\AttributeBehavior， 这个类中定义了要处理的两个事件beforeInsert(), beforeUpdate() 以及它们要触发的方法(方法里就是给created_at/updated_at赋值), 当一个模型使用了TimeStampBehavior就可以自动处理created_at/updated_at啦 事件/行为的应用场景 我想在请求过来的时候，先将请求的 IP 的记录到数据库，然后才进行对应的相应的请求处理。 当用户评论一篇文章时，可以触发一个评论对象添加（“add”）事件。 邮件程序对象成功发出消息时可触发 messageSent 事件。如想追踪成功发送的消息，可以附加相应追踪代码到 messageSent 事件。 用户登录成功后触发afterLogin事件。可以在该事件处绑定yii AfterLoginBehavior行为，更新用户信息 参考：Yii事件使用业务场景 http://www.jianshu.com/p/da4c3cfe55fa 其实行为的最终目地还是绑定事件，这里有一个很清晰的例子：场景是在后台，每个用户操作了什么（也就是访问了那个链接），都会记录日志访问： https://yii-china.org/topic/740 还有其它的应用场景请留言帮助我完善这篇博文。关于事件的触发/绑定，行为的定义/绑定/解除强烈推荐大家看《深入理解Yii2.0》","categories":[{"name":"Yii2","slug":"Yii2","permalink":"https://nutshell.com/categories/Yii2/"}],"tags":[{"name":"Yii2.0","slug":"Yii2-0","permalink":"https://nutshell.com/tags/Yii2-0/"}]},{"title":"Larave 学习中推荐参考的文章","slug":"Larave-学习中推荐参考的文章","date":"2018-05-12T01:34:29.000Z","updated":"2018-06-05T14:11:46.094Z","comments":true,"path":"2018/05/12/Larave-学习中推荐参考的文章/","link":"","permalink":"https://nutshell.com/2018/05/12/Larave-学习中推荐参考的文章/","excerpt":"在做项目的过程中经常需要参考前辈的思路，查询踩过的坑，在此推荐。","text":"在做项目的过程中经常需要参考前辈的思路，查询踩过的坑，在此推荐。 性能优化 文章标题 作者 链接地址 记一次 Laravel 应用性能调优经历 精进吧Aaron https://segmentfault.com/a/1190000011569012#articleHeader16 使用技巧 文章标题 作者 链接地址 Laravel如何优雅的使用Swoole 万年场保安 https://www.jianshu.com/p/4ad04f8ff907 Laravel redis使用教程 丶老中医 https://www.cnblogs.com/love-snow/articles/7778532.html Laravel+Swoole 完成一个简单的在线聊天室 Nine https://laravel-china.org/articles/6287/laravelswoole-completes-a-simple-online-chat-room","categories":[{"name":"Laravel","slug":"laravel","permalink":"https://nutshell.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nutshell.com/tags/laravel/"},{"name":"参考文章","slug":"参考文章","permalink":"https://nutshell.com/tags/参考文章/"}]},{"title":"在 laravel 中使用 swoole websocket 踩过的坑","slug":"在-laravel-中使用-swoole-websocket-踩过的坑","date":"2018-05-10T01:40:34.000Z","updated":"2018-05-29T03:42:10.313Z","comments":true,"path":"2018/05/10/在-laravel-中使用-swoole-websocket-踩过的坑/","link":"","permalink":"https://nutshell.com/2018/05/10/在-laravel-中使用-swoole-websocket-踩过的坑/","excerpt":"最近做了一个项目，两个用户在同一个房间内答题，需要长连接以及通知用户，最初我们用轮询做，坑一大堆。显然使用 websocke 是最好的选择，因为可能需要支持多台服务器，就用 redis 做转发，把每一个服务器作为一个频道。","text":"最近做了一个项目，两个用户在同一个房间内答题，需要长连接以及通知用户，最初我们用轮询做，坑一大堆。显然使用 websocke 是最好的选择，因为可能需要支持多台服务器，就用 redis 做转发，把每一个服务器作为一个频道。 使用步骤第一步：安装 swoole 扩展参考文档 swoole 第二步：自定义 artisan 命令参考Laravel如何优雅的使用Swoole app/Console/Commands/Swoole12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace App\\Console\\Commands;use App\\Handlers\\SwooleHandler;use Illuminate\\Console\\Command;class Swoole extends Command&#123; protected $signature = 'swoole:action &#123;action&#125;'; protected $description = 'swoole command'; protected $serv; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $action = $this-&gt;argument('action'); switch ($action) &#123; case 'start': $this-&gt;start(); break; case 'stop': $this-&gt;stop(); break; case 'restart': $this-&gt;restart(); break; &#125; &#125; /** * 开启websocket */ private function start() &#123; $this-&gt;serv = new \\swoole_websocket_server(config('swoole.host'), config('swoole.port')); $handler = new SwooleHandler(); $this-&gt;serv-&gt;on('handshake', array($handler, 'onHandshake'));// $this-&gt;serv-&gt;on('open', array($handler, 'onConnect')); $this-&gt;serv-&gt;on('message', array($handler, 'onReceive')); $this-&gt;serv-&gt;on('close', array($handler, 'onClose')); $this-&gt;serv-&gt;start(); &#125;&#125; 使用 php artisan swoole:action start 即可启动 websocket 服务 小提示：@1. 在 start 方法中绑定了 handshake 事件，原因是我在项目中有很多个子模块用到 websoket 但是一个服务器一个端口只能有一个 websocket 服务，就想到用 websocket 的子协议（protocol）来区分模块. 参考onHandShake@2. handshake 和 open 只能绑定一个，无需自定义握手的情况下绑定 open 即可。参考onHandshake - swoole-websocket 第三步 在绑定的 handler 中处理事件在绑定的 SwooleHandler 相应事件中处理业务逻辑即可 踩过的坑部署到多台服务器 用 redis 转发消息，将每一台服务器作为一个订阅频道，当用户连接到这个服务器时进行绑定(服务器，客服端标识，用户标识),注意客服端标识会冲突(每台服务器都是从1开始递增)有消息要通知用户时，取出所在服务器即频道和客服端标识 1.订阅频道app/Handlers/SwooleHandler1234567891011121314151617181920212223242526272829public function onHandshake()&#123; //... $this-&gt;createRedisClient(); //...&#125;public function createRedisClient()&#123; $more = Redis::hget('redis_listen', env('SWOOLE_HOST')); if (empty($more) || !$more) &#123; //redis 订阅 $client = new \\swoole_redis; $client-&gt;__construct($options = ['password' =&gt; env('REDIS_PASSWORD')]); $ws = $this-&gt;serv; $client-&gt;on('message', function (\\swoole_redis $client, $result) use ($ws) &#123; if ($result[0] == 'message') &#123; $message = explode('@@', $result[2]); var_dump($message); $ws-&gt;push($message[0], $message[1]); &#125;//频道 &#125;); $client-&gt;connect(env('REDIS_HOST'), env('REDIS_PORT'), function (\\swoole_redis $client, $result) &#123; $client-&gt;subscribe(env('SWOOLE_HOST')); &#125;); Redis::hset('redis_listen', env('SWOOLE_HOST'), true); &#125;&#125; 2.绑定服务器，客服端标识，用户标识123456789101112131415//绑定 websocketServer 与用户 public static function bindServer($login_key, $fd) &#123; $User = new User; $sess_user = $User-&gt;nosqlSession($login_key); if (!$sess_user) &#123; //找不到用户，就绑定不到对应的服务器，用户就接收不到消息，包括错误，此处直接向对应服务器报错 Redis::publish(env('SWOOLE_HOST'), $fd . '@@' . json_encode([ 'message' =&gt; 'User is inactivated', 'type' =&gt; 'error' ])); throw new ModelNotFoundException('User is inactivated'); &#125; Redis::hset('server', $sess_user['id'], env('SWOOLE_HOST')); &#125; 3.找出用户对应服务器，客户端标识123$user_id = intval(Redis::zscore(\"room:&#123;$room_id&#125;\", $fd));$server = Redis::hget('server', $user_id);Redis::publish($server, $fd . '@@' . $message); 用 redis 订阅消息转发到 websocket，一旦有异常抛出没有接住，会导致 serv shutdown, redis 无法订阅消息解决思路： 启动 redis client 后打一个标记 serv shutdown 后，删除这个标记 在每一次的 onMessage 事件中，检查这个标记，没有就再次创建新的 redis client app/Console/Commands/Swoole start function1234567register_shutdown_function(function () &#123; $error = error_get_last(); if (isset($error['type'])) &#123; var_dump('errrrrrrr!!!!!'); Redis::hdel('redis_listen', env('SWOOLE_HOST')); &#125; &#125;);","categories":[{"name":"Laravel","slug":"laravel","permalink":"https://nutshell.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nutshell.com/tags/laravel/"},{"name":"websocket","slug":"websocket","permalink":"https://nutshell.com/tags/websocket/"}]},{"title":"访问器与修改器","slug":"访问器与修改器","date":"2018-05-10T01:35:10.000Z","updated":"2018-05-12T12:51:43.598Z","comments":true,"path":"2018/05/10/访问器与修改器/","link":"","permalink":"https://nutshell.com/2018/05/10/访问器与修改器/","excerpt":"对数据模型操作时，常常需要写入前处理数据，或者展示时对数据预处理，laravel 提供了修改器和访问器来实现这一需求。参考文档 Laravel China","text":"对数据模型操作时，常常需要写入前处理数据，或者展示时对数据预处理，laravel 提供了修改器和访问器来实现这一需求。参考文档 Laravel China 1.修改器例如存储密码时，需要将服务端接收的明文加密再存入数据库，就可以使用修改器。 Ex: setNickNameAttribute($value)1234567public function setLinkAttribute($value)&#123; if (strstr($value, env('OSS_BUCKET') == false))&#123; $value = \"https://\" . env('OSS_BUCKET') . '.' . env('OSS_END_POINT') . '/' . $value; &#125; $this-&gt;attributes['link'] = $value;&#125; 2.访问器当我们从实例中获取某些属性值的时候，访问器允许我们对 Eloquent 属性值进行动态修改，而不是真的修改了数据库值。访问器的命名规范与修改器类似，只是将 set 换成 get 而已： Ex: getCtreateAtAttribute($value)1234public function getCreateAtAttribute($value)&#123; return $this-&gt;attributes['create_at'] = date('Y-m-d H:i:s');&#125; 小提示 访问器与修改器不同，需要 return","categories":[{"name":"Laravel","slug":"laravel","permalink":"https://nutshell.com/categories/laravel/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://nutshell.com/tags/laravel/"},{"name":"model","slug":"model","permalink":"https://nutshell.com/tags/model/"}]}]}